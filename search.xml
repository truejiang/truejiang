<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[学习英语语法 - Day One]]></title>
    <url>%2F2018%2F05%2F31%2FLearn%20grammar%20day%20one%2F</url>
    <content type="text"><![CDATA[作为一个断断续续，懒懒散散学习了1年多的英语学渣而言，学习英语实在有点痛苦，想我初中时英语150，常年还140以上呢。然鹅~ 尝试过各种单词APP，百词斩，扇贝，多领国，乐词。其中百词斩和扇贝用的最久，在上面背的单词数都超过了4K，然鹅~现在记得还剩几百个吧。 一开始我也是只从背单词入手，结果发现光背不用是没有实际意义的，忘记的太快，如何去用呢，最经济实惠的就是 Reading 啦，一篇文章都是由一个一个句子组成，句子的组成结构由语法而定。 背景已介绍完，下面开始记录一些学习的经验。如果你已经开始背单词，但是对于一些句子仍是一脸懵逼，而且想要搞个明白，那么继续往下看了。 什么是句子？基本的句子需包含以下内容：至少有一个主语；有且只有一个谓语动词；能表达完整的意思。三者缺一不可。下面介绍下五种基础句型： 五种基础句型1）主语 + 动词（主谓）She（主） smiled（谓） 用上面的句子三要素套一下，完全OK的。 提到上面的句子呢，我们就不得不提到一个能唤醒你远古回忆的词，不及物动词（不及物就是不用跟东西的意思，如上面句子的动词 smiled），也就是我们常看的 Vi 。那么怎么知道哪个单词是不及物动词呢？当然是背单词啦。。。 为什会有不及物呢，我们先忘记英语，用我们的母语思考下，一些动词，比如 我吃了，我笑了，我哭了，我走了。这些都可以不用跟随一些事物但是就可以表达一个完整的意思。所以这类动词被叫作不及物动词。另外一些情况做及物动词，我玩西瓜，我写作业，这些后面都要跟上一个事物才能表达完整意思的，叫作及物动词。一个动词既可以做及物动词也可以做不及物动词，比如 smile，用作 微笑 的时候是不及物，用作 微笑着表示 的时候不及物。 既然有不及物动词，那么肯定也有及物动词。 2）主语 + 动词 + 宾语（主谓宾）I’m（主） writing （谓） an article （宾） 这里的 writing 就是及物动词Vt`，这种在日常中更加普遍。 3）主语 + 动词 + 间接宾语（一般指人）+ 直接宾语（一般指物）I （主） want to give （谓）her（间宾（人）） a big surprise （直宾（物）） 上面的句子也就常说的双宾语结构，日常中大量见到：He gave me a book, I taught her how to programme，等等。 先介绍下直接宾语和间接宾语的含义。直接宾语是谓语动词的承受者，间接宾语表示谓语动词的方向（对谁做）或者动作的目标（为谁做），间接宾语紧接在谓语动词后，但它不能单独存在，并且能和直接宾语组成双宾语。 不明白？看下例子： She showed me her room. 她向我展示她的房间（her room 作为 showed 的承受者作为直接宾语，展示的动作是为 me，所以 me 作为间接宾语）。是不是很 easy。 间接宾语还可以由 to（表示动作的方向）或者for（表示动作目标）来表示。比如我们上面写的 give sb sth 和 give sth to sb 是完全一个意思的。 常用的能接双宾语的及物动词有：give, teach, buy, lend, find, hand, leave, sell, show, read, pay, make, offer, build, pass, bring, cook,refuse等。 是不是感觉一下子就记住一堆的单词和句型了。 4）主语 + 动词 + 宾语 + 宾补（宾语补足语） I’m （主语） going to paint（谓语动词） the desk（宾语） pink（宾语）. 上面的句子呢，其实不要后面的 pink,直接 I’m going to paint the desk。我想要给桌子涂漆，可以表达出来一些意思了，但是感觉还是不完整，我是要涂什么漆，或者涂成什么样子呢？这样就多了一个补充的说明，是要涂成 pink 粉红色。 这里的pink本身是一个形容词，是形容词做宾语补足语。 说下宾语补足语的含义：在英语中有些及物动词，接了宾语意义仍不完整，还需要有1个其他的句子成分，来补充说明宾语的意义、状态等，称为宾语补足语，简称宾补。 那么还有那些可以充当宾语补足语呢？常见的有：不定式，现在分词，过去分词，副词，介宾短语。一般情况下，宾补都是紧跟宾语后面的。前面说的常见都是啥？因为暂时不在我们本篇文章学习内容中，我们以后再讲。。先举几个栗子： We consider him (to be) a good teacher. 我们认为他是一个好老师 I’d prefer you to leave him alone. 我希望你不要打扰他 还不太明白？再举个栗子： I heard Jean singing this morning 我听到Jean 唱歌了，啥时候唱的？今天早上啊。 小明：I love you.小红：多久啊。不补充下？小明：I love you forever.小红：这就对啦。 5）主语 + 系动词 + 表语This article（主语） feels（系动词） great（表语）. 定语定语的含义：连接主语和表语的动词称为连系动词。不能独立存在 ，后面必须跟表语一起构成复合谓语，表示主语的身份、类别、特征、状态等。分为以下几种： 状态系动词用来表示主语状态，只有 be 一词，例如：He is a teacher. 他是一名教师。 持续系动词用来表示主语继续或保持一种状况或态度，主要有 keep,remain,stay,stay,lay,stand.例如：He always kept silent at meeting. 他开会时总保持沉默。 表象系动词用来表示”看起来像”这一概念，主要有seem, appear, look, 例如He looks tired. 他看起来很累。 感官系动词顾名思义，表示感官方面的动词，主要有fell,smell,sound,taste,例如：This flower smell very sweet. 这朵花闻起来很香。 变化系动词主要表示主语要变成什么样，主要有become,grow,turn,fall,get,go,come,run,例如：He became mad after that. 自那之后，他疯了。 终止系动词表示主语已终止动作，主要有prove,turn out,表示“证实”，“变成”之意，例如：The rumor proved false. 这谣言证实有假。 总结下，常见类型归纳：be动词（am，is，are），感官动词（feel，look，smell，sound，taste，seem），“变得”词（get，become，turn，grow），“保持”（remain，keep）。 表语表语的含义：表语是说明主语的身份、性质、品性、特征和状态的，表语位于系动词之后，与系动词联系十分紧密，有系动词就有表语，有表语就有系动词。通常由名词、形容词、副词、介词短语、不定式、动词的-ing、从句来充当。 用现在的话来讲就是，他俩是对好基友，都是结伴出行的。结合上面讲的系动词我们看下面的例子： I am fine （fine是形容词，做表语） He is a boy （boy是名词，做表语） Five plus tow is seven （seven是数词，作表语） I am here （here是副词，做表语） I don’t fell at ease (at ease是借此短语，做表语) I am coding (coding 是动名词，作表语) 简单来说这种句型就是想要描述清楚，我是谁，我在哪里，我要到哪里去，变成什么样之类的巴拉巴拉了。 以上就是几种基础句型的简单介绍，看完应该有些头绪了吧，如果没有，那么就再看一遍吧~最后任何学习的方法，都是多看+多练+多想。学习本不易，且学且珍惜~]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>英语学习</tag>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stylus - 入门]]></title>
    <url>%2F2018%2F05%2F29%2Fstylus%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简介Stylus，2010年产生，相对于 LESS 和 SASS 出来的时间比较晚，来自Node.js社区，主要用来给 Node 项目进行CSS预处理支持，但现在Node普及的情况下，而且还支持 JavaScript 的写法。 先说下 stylus 的一些优点 stylus的代码很简介，{} 甚至 : 都可以省略点，缩进的写法让层级看着非常直观。 @import 可以引用其他 样式文件，使样式也可以模块化，方便维护。 函数和Mixin，魔法师一般的利器，复用代码，条件判断，样样都行。 运行环境相对简单，有Node即可，sass需要安装 ruby 使用配置环境使用非常简单，首先确定你的系统中有安装 Node，如果没有请点击前面的链接安装。npm 和 Node 是一起打包安装的。然后打开任意文件夹，新建一个目录 stylus，进入该目录，安装 stylus 1npm install stylus --save 另外新建一个 stylus 文件，文件的后缀是 .styl。所以我们就叫 stylus.styl 吧。 另外新建一个 js 文件叫 stylus_run.js，然后代码如下： 123456789101112const css = require(&apos;stylus&apos;) str = require(&apos;fs&apos;).readFileSync(&apos;stylus.styl&apos;, &apos;utf-8&apos;)css.render(str, &#123; filename: &apos;index.styl&apos;&#125;, function(err, css) &#123; if (err) throw err var http = require(&apos;http&apos;) http.createServer(function(req, res)&#123; res.writeHead(200, &#123;&apos;Content-Type&apos; : &apos;text/css&apos;&#125;) res.end(css) &#125;).listen(1337, &apos;127.0.0.1&apos;) console.log(&apos;success&apos;)&#125;) 上面的代码是引用的 张鑫旭大神的，自己懒的去搭了，代码很简单，就是请求 stylus 包，读取我们的 stylus文件，然后渲染。最后吧渲染后的内容，挂到 http://127.0.0.1:1337/ 上。 然后我们回到刚刚的 stylus.styl 文件，先随便玩玩吧，输入一些代码如下： 123456789font-size-14px = 14pxfont = font-size-14px &apos;微软雅黑&apos;, Arialpad(n) margin (- n)body pad(10px) 在命令行输入 node stylus_run，然后在浏览器输入 http://127.0.0.1:1337/ 1234body &#123; margin: -10px; padding: 25px;&#125; 就是这么神奇，就像写 JS 一样。下面我们看下各个用法。 选择器常规的写法,我们可以用缩进和空格代替{} 和 : 12body color #fff 等于CSS123body &#123; color: #fff&#125; 多个选择器，可以用 , 或者回车: 123456.p1, .p2 color #333// 或者.p1.p2 color #333 注意上面的代码.p1和.p2新行不要缩进，否则就成了 .p1下的.p2了。 父级引用，类似于 sass：1234div color #333 &amp;.div1 color #f00 等于CSS123456div &#123; color #333&#125;div .div1 &#123; color #f00&#125; 总的来说和CSS本身的选择器基本一致，多了一些比如 父级引用 等。 变量变量是 stylus 一个很强大的功能。可以指定表达式为变量，方便于复用，比如我们一般在项目中，会有很多通用的字体大小，字体颜色，背景色等。我们可以统一写了如下： 1234567891011121314151617181920212223242526// 颜色定义规范$color-background-nav = #222$color-background-d = rgba(0, 0, 0, 0.3)$color-highlight-background = #333$color-dialog-background = #666$color-theme = #ffcd32$color-theme-d = rgba(255, 205, 49, 0.5)$color-sub-theme = #d93f30$color-text = #fff$color-text-d = rgba(255, 255, 255, 0.3)$color-text-l = rgba(255, 255, 255, 0.5)$color-text-ll = rgba(255, 255, 255, 0.8)// 字体定义规范$font-size-small-s = 10px$font-size-small = 12px$font-size-medium = 14px$font-size-medium-x = 16px$font-size-large = 18px$font-size-large-x = 22px// 使用的话就是.nav font-size $font-size-small-s background-color $color-background-nav 上面这样写很一目了然，比如我知道这个是给nav的背景色，给小号的字体 属性查找： 123456789101112131415161718#logo position: absolute top: 50% left: 50% width: w = 150px height: h = 80px margin-left: -(w / 2) margin-top: -(h / 2)// 也可以这么写#logo position: absolute top: 50% left: 50% width: 150px height: 80px margin-left: -(@width / 2) margin-top: -(@height / 2) 相当于是一个局部的变量。 插值Stylus 支持通过使用 {} 字段包围表达式来插入值。类似于ES6的字符串拼接${variables}： 123456addColorClass(className, colors) &amp;.&#123;className&#125; color colorsdiv addColorClass(yellowColor, yellow) 等同于：123div.yellowColor &#123; color: #ff0;&#125; 运算符运算符的优先等级如下：123456789101112131415[]! ~ + -is defined** * / %+ -... ..&lt;= &gt;= &lt; &gt;in== is != is not isntis a&amp;&amp; and || or?:= := ?= += -= *= /= %=notif unless 算术运算符是支持 带单位的： 1215px - 5px // 10px 15px * 5px // 75px 也支持三元操作符：123color = color is defined ? color : white// stylus 没有 == 和 === 用 is 判断是否相等 混合书写混入的写法和定义函数方法一致。 1234567border-nPx (n) border-width n.box border-nPx (10px) //或者省略大括号 border-nPx 10px 等于CSS：123.box&#123; border-width:10px &#125; 我们还可以传入所有的 参数 1234addBorder() border arguments.box addBorder 1px solid pink 等于CSS：123.box&#123; border: 1px solid pink&#125; 也可以设置默认参数：12345678addBlock(w = 100px, h = 100px, bgColor = #fff) width w height h background-color bgColor.firstBlock addBlock().secondBlock addBlock(200px, 200px, #F00) 等于CSS：12345678910.firstBlock &#123; width: 100px; height: 100px; background-color: #fff;&#125;.secondBlock &#123; width: 200px; height: 200px; background-color: #f00;&#125; 方法和混合差不多，但是可以返回值 12345add(a, b) a + bbody padding add(10px, 5) 等于CSS：123body &#123; padding: 15px;&#125; 方法也支持参数默认值和判断： 123456789101112stripe(even = #fff, odd = #eee, paddingOrMargin = true) tr background-color: odd &amp;.even &amp;.nth-child(even) background-color: even if paddingOrMargin padding: 4px 4px else margin: 4px 4pxtable stripe(#f00, #f32, false) 等于CSS：12345678table tr &#123; background-color: #f32; margin: 4px 4px;&#125;table tr.even,table tr.nth-child(even) &#123; background-color: #f00;&#125; 注释Stylus 支持3种注释，单行，多行，多行缓冲 12345678910111213141516171819// 我是单行注释!body padding 5px // 蛋疼的padding/* * 我是多行注释 * 给定数值合体 */add(a, b) a + b/*! * 我是多行缓冲注释，和多行注释类似，但是在压缩时会忽略这段注释 * 给定数值合体 */add(a, b) a + b 迭代Stylus 也支持迭代，语法如下：1for &lt;val-name&gt; [, &lt;key-name&gt;] in &lt;expression&gt; 实际使用如下： 123456789addColor(props) props = arguments if length(arguments) &gt; 1 for prop in props div.&#123;prop[0]&#125; color: prop[1]body list = (blueColor blue) (redColor #f00) (blackColor #333) addColor(list) 等于CSS：123456789101112body div.blueColor &#123; color: #00f;&#125;body div.redColor &#123; color: #f00;&#125;body div.blackColor &#123; color: #333;&#125;body div.grayColor &#123; color: #666;&#125; 是不是超爽的，省了很多代码。 导入（@import）这也是Stylus 常用的功能，可以导入CSS，也可以导入stylus文件 1@import &apos;reset.css&apos; 比如我们项目中常用结构会这样： 123456/stylus |--index.styl |--icon.styl |--mixin.styl |--reset.styl |--variable.styl 一般在 index.styl 中导入所有基础的 styl，在外部引用时直接引入 index.styl，index.style代码如下： 12@import &quot;./reset.styl&quot;@import &quot;./icon.styl&quot; 媒体（@media）和CSS一致1234@media print #header #footer display none 等于CSS：123456@media print &#123; #header, #footer &#123; display: none; &#125;&#125; 这里有个小技巧，比如我们平时手机页面会根据物理像素去给不同大小的图片，可以代码如下：1234bg-image($url) background-image: url($url + &quot;@2x.png&quot;) @media (-webkit-min-device-pixel-ratio: 3),(min-device-pixel-ratio: 3) background-image: url($url + &quot;@3x.png&quot;) 注意上面代码图片的实际路径。一些常用的用法就是上面这些了。以后深入学习和使用后再更新，拜~]]></content>
      <categories>
        <category>stylus</category>
      </categories>
      <tags>
        <tag>css预处理器</tag>
        <tag>stylus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 常用配置（不定期更新）]]></title>
    <url>%2F2018%2F05%2F12%2Fwebpack%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Vue-cli 中的一些配置css样式，如自动加前缀，浏览器兼容等。首先确保根目录的 package.json 安装了对应的依赖 postcss-loader, autoprefixer, css-loader 其他比如使用了 sass, stylus, sccc 之类的，还需要安装对应的依赖 stylus, stylus-loader, sass, sass-loader等待。 在项目根目录有2个文件，.postcssrc.js，postcss-loader 会默认读取前面的文件，配置如下（这里使用的是webpack4） 12345678module.exports = &#123; &quot;plugins&quot;: &#123; &quot;postcss-import&quot;: &#123;&#125;, &quot;postcss-url&quot;: &#123;&#125;, // to edit target browsers: use &quot;browserslist&quot; field in package.json &quot;autoprefixer&quot;: &#123;&#125; &#125;&#125; 然后在 package.json 配置如下： 1234567&quot;browserslist&quot;: [ &quot;Firefox &gt; 20&quot;, &quot;iOS &gt;= 7&quot;, &quot;ie &gt;= 8&quot;, &quot;last 5 versions&quot;, &quot;&gt; 5%&quot;] 详细全部的配置如下： 1234567891011121314151617181920&gt; 5%: versions selected by global usage statistics. &gt;=, &lt; and &lt;= work too.&gt; 5% in US: uses USA usage statistics. It accepts two-letter country code.&gt; 5% in alt-AS: uses Asia region usage statistics. List of all region codes can be found at caniuse-lite/data/regions.&gt; 5% in my stats: uses custom usage data.cover 99.5%: most popular browsers that provide coverage.cover 99.5% in US: same as above, with two-letter country code.cover 99.5% in my stats: uses custom usage data.extends browserslist-config-mycompany: take queries from browserslist-config-mycompany npm package.ie 6-8: selects an inclusive range of versions.Firefox &gt; 20: versions of Firefox newer than 20. &gt;=, &lt; and &lt;= work too.iOS 7: the iOS browser version 7 directly.Firefox ESR: the latest [Firefox ESR] version.unreleased versions or unreleased Chrome versions: alpha and beta versions.last 2 major versions or last 2 iOS major versions: all minor/patch releases of last 2 major versions.since 2015 or last 2 years: all versions released since year 2015 (also since 2015-03 and since 2015-03-10).dead: browsers from last 2 version query, but with less than 0.5% in global usage statistics and without official support or updates for 24 months. Right now it is IE 10, IE_Mob 10, BlackBerry 10, BlackBerry 7, and OperaMobile 12.1.last 2 versions: the last 2 versions for each browser.last 2 Chrome versions: the last 2 versions of Chrome browser.defaults: Browserslist’s default browsers (&gt; 0.5%, last 2 versions, Firefox ESR, not dead).not ie &lt;= 8: exclude browsers selected by previous queries. 参考链接 如何设置一些本地的路由访问有时候我们会需要设置一些本地的文件，访问接口时我们想更统一和简化一些。可以在根目录下的 build 文件夹下找到 webpack.dev.conf.js 文件。在 devServer 中添加 before (app) {} 然后在里面填写路由请求方式。详细代码如下： 123456789101112131415161718192021222324252627282930313233343536373839devServer: &#123; ....some code, before (app) &#123; app.get(url, (req, res) =&gt; &#123; // dosometing &#125;) &#125; &#125;// 如果要读取本地的资源，如一些json文件，可以先申明变量拿到资源var appData = require(&apos;../data.json&apos;) //加载本地文件// 这是的appData拿到的是data.json的内容，data.json的结构如下&#123; &quot;seller&quot;: &#123;...&#125;, &quot;shoppingList&quot;: &#123;...&#125;&#125;//获取对应本地数据var seller = appData.seller var shoppingList = appData.shoppingListdevServer: &#123; ....some code, before (app) &#123; app.api(/api/seller, (req, res) =&gt; &#123; res.json(&#123; errno: 0, data: seller &#125;) //接口返回json数据，上面配置的数据seller就赋值给data请求后调用 &#125;), app.api(/api/shoppingList, (req, res) =&gt; &#123; res.json(&#123; errno: 0, data: shoppingList &#125;) &#125;) &#125; &#125; …未完待续]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this 的使用方法]]></title>
    <url>%2F2018%2F03%2F05%2Fthis%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[记录下 this 的几种情况this 是 JavaScript 的一个关键字，在 JavaScript 运行时，根据不同运行环境表现各有不同，此外在严格模式和非严格模式也有不同。在大多数情况下函数的调用方式决定了 this 的值 全局上下文无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）this 都指代全局对象。 123456789// 在全局作用域下，window 和 this 完全一样console.log(this === window) // truevar a = 22window.a // 22this.a = 23 window.a // 23this.a === window.a // true 纯粹的函数调用属于全局调用时，this代表全局对象的 Global，浏览器下就是 window 1234567891011let name = &apos;cjo&apos;function person()&#123; console.log(this.name)&#125;person() // &apos;cjo&apos;// 可以理解成 var person = function()&#123; console.log(this.name)&#125;// person 在使用时指向的全局 作为对象方法的调用作为某个对象的方法调用时，这是this就指向这个上级对象 123456789101112var x = 1var foo = &#123; x: 2, bar()&#123; var x = 3 console.log(this.x) return function baz()&#123; console.log(this.x) &#125; &#125;&#125;foo.bar()() //2, 1 上面的代码第一个输出2，因为 bar 是foo对象下一个方法，调用时，this 就是 foo。所以是 2。后面的 this 是 bar 函数下的一个方法调用，函数的使用 this 指向全局的 window。 构造函数调用123456789var name = &apos;cjo&apos;function Person(name)&#123; this.name = name&#125;var slash = new Person(&apos;slash&apos;)console.log(slash.name) // &apos;slash&apos;console.log(name) 上面的代码 name 使用的 slash 传入的参数的值，说明里面的 this 不是全局的。 apply或者call调用apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。 123456789101112131415var x = 0;function test()&#123; alert(this.x);&#125;var o=&#123;&#125;;o.x = 1;o.m = test;o.m.apply(); //0 apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。 如果把最后一行代码修改为 1o.m.apply(o); //1 运行结果就变成了1，证明了这时this代表的是对象o。 箭头函数在箭头函数中，this 与封闭词法上下文的 this 保持一致。在全局代码中，它将被设置为全局对象： 12var foo = (() =&gt; this);console.log(foo() === window); // true 作为一个DOM事件处理函数当函数被用作事件处理函数时，它的this指向触发事件的元素 12345678910111213141516// 被调用时，将关联的元素变成蓝色function bluify(e)&#123; console.log(this === e.currentTarget); // 总是 true // 当 currentTarget 和 target 是同一个对象时为 true console.log(this === e.target); this.style.backgroundColor = &apos;#A5D9F3&apos;;&#125;// 获取文档中的所有元素的列表var elements = document.getElementsByTagName(&apos;*&apos;);// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色for(var i=0 ; i&lt;elements.length ; i++)&#123; elements[i].addEventListener(&apos;click&apos;, bluify, false);&#125; 作为一个内联事件处理函数当代码被内联on-event 处理函数调用时，它的this指向监听器所在的DOM元素： 123&lt;button onclick=&quot;alert(this.tagName.toLowerCase());&quot;&gt; Show this&lt;/button&gt; 参考资料: this - JavaScript | MDN Javascript的this用法 - 阮一峰的网络日志]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS编程精解阅读笔记 - 数据结构：对象与数组]]></title>
    <url>%2F2018%2F02%2F17%2FEloquent%20JavaScript%20Reading%20Notes%20-%20Obj%2F</url>
    <content type="text"><![CDATA[数据结构：对象与数组对象对象是一个包含相关数据和方法的集合（通常由一些变量和函数组成，我们称之为对象里面的属性和方法）。 属性 和 值属性可以理解为键值对的键名 123456789var person = &#123; name: &apos;slash&apos;&#125;person.name --&gt; &apos;slash&apos;person[&apos;name&apos;]--&gt; &apos;slash&apos; 可以采用2种方法访问属性的值。使用中括号或者使用点标记法。点标记法是中括号的速记法，只有在属性名是一个合法的变量名时才能使用，也就是说属性不包含任何空格或符号且不以数字开头。如果查询的属性名是不存在的，会得到一个 undefined 值，关键字 delete 用于删除属性。如果用 = 操作符设置一个不存在的属性时，将会为对象添加一个新的属性。 123456789let person = &#123;name: &apos;slash&apos;, sexy: &apos;male&apos;, age: 29&#125;person.age = 27person.age // 27delete person.ageperson.age // undefinedperson.pet = &apos;咻咻&apos;person // &#123;name: &apos;slash&apos;, sexy: &apos;male&apos;, pet: &apos;咻咻&apos;&#125; 属性名称如果不是一个合法的变量名称，则不可以用点标记法访问，只能用中括号的形式访问。 1234567var person = &#123;&quot;full name&quot;: &apos;slash chu&apos;, 2: 2&#125;person[&apos;full name&apos;] // &apos;slash chu&apos;person[&apos;2&apos;] // 2person[1+1] // 2let fullName = &apos;full name&apos;person[fullName] // &apos;slash chu&apos; 操作符 in 可以用来判断一个对象是否含有某个属性，返回一个布尔值，注意属性还是写的字符串或者一个变量。 1234let person = &#123;name: &apos;slash&apos;, sexy: &apos;male&apos;, age: 29&#125;&apos;name&apos; in person // true&apos;fullName&apos; in person // false 易变性123456789let object1 = &#123;value: 10&#125;let object2 = object1let object3 = &#123;value: 10&#125;object1 === object2 // trueobject1 === object3 // falseobject2.value = 15object1.value // 15 上面的代码 object1 和 object3 虽然值看着一样，但实际是不相等的，只有object2是object1的引用，所以相等，而且在修改了object2的值后，object1的值也发生了改变。这里非常喜欢作者的一个比喻，变量和赋值之间是一个章鱼触手的抓取，比如object1和object2是抓的同一个对象，我们修改是改的变量抓取的值，所以在改变了object1或者object2的某一个属性，实际2个的值都会改变。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS编程精解阅读笔记 - 函数]]></title>
    <url>%2F2018%2F02%2F15%2FEloquent%20JavaScript%20Reading%20Notes%20-%20Fn%2F</url>
    <content type="text"><![CDATA[剖析函数的定义123456function square(x) &#123; // do somethings return x * x&#125;square(12)--&gt; 144 关键字 function 用于创建新函数，function 后面如果是变量名（如上面的 square 记得中间有空格），新函数就会使用该变量名保存。变量名后面是一组参数名称，用括号括起来（如上面的 (x) x 是参数可以有多个），最后的 {} 是函数体，在里面写有函数要做的事情。关键字 return 后面是表达式，用于确定函数返回的值，这个是可选的，如果不写，默认返回的是 undefined，当代码遇到 return 语句时，立即跳出但求的函数体 {} 并将返回值传递给调用该函数的代码。 函数参数的作用类似于变量，可以在函数体内使用，作用域也只限于函数体内，但具体的值是由函数调用者给予，而不是函数自身去传递的。但函数也可以在内部去为这些参数赋予新值。 1234567function person(name, age) &#123; var name = &apos;小明&apos; return name + &apos;今年&apos; + age + &apos;岁了&apos;&#125;person(&apos;小红&apos;, 18)--&gt; 小明今年18岁了 内部创建了一个变量去接受了参数name的值。但一般不会这么做，没有实际意义，如果要设置默认值的话，可以这样12345678function person(name, age) &#123; var name = name || &apos;小明&apos; return name + &apos;今年&apos; + age + &apos;岁了&apos;&#125;// ES6function person(name=&quot;小明&quot;, age) &#123; return name + &apos;今年&apos; + age + &apos;岁了&apos;&#125; 定义的顺序12345sayHello(&apos;Hello, world!&apos;)function sayHello(str)&#123; return str&#125; 上面的代码一样可以运行，是因为计算机在开始执行语句之前，会查找所有的 function 定义，然后保存相关的 function。 局部变量函数的一个特征是内部创建的变量是函数的局部函数。也就是说，上面的变量 name 在每次函数执行时都会创建一次，函数退出时则不再存在。局部变量只适用于函数的参数和函数内部以 var 关键字定义的变量。如果没有定义同名的局部变量，函数内部则可能访问到全局变量。 12345678910111213141516var a = &apos;A&apos;function setVarToB() &#123; a = &apos;B&apos; &#125;setVarToB() //这个时候返回了全局变量。a--&gt; &apos;B&apos;function setVarToC() &#123; var a a = &apos;C&apos;&#125;setVarToC() //因为内部a --&gt; 提示：上面的函数都没有包含 return 语句，它们之所以被调用是为了实现里面复制的功能，而不是创建值（因为函数内部创建的都是局部函数，退出时消失）。这类函数返回值是 undefined。 闭包包裹一些局部变量的一个函数叫作闭包。该行为不仅让我们不用担心变量是否依然存在，而且还可以创造性的使用函数值。 123456789function makeAdder(amount) &#123; return function(number) &#123; return number + amount &#125; &#125;var addTwo = makeAdder(2)addTwo(3)--&gt; 5 上面的代码中另外一个特点就是让函数内的局部函数在调用时没有被销毁，而是等后面return 的函数中再次使用。 参数Javascript 不会限制传入函数的参数数目。如果传入的参数过多，多语的参数会被忽略，如果传入的过少，未传入的参数的值是 undefined 递归因为函数可以调用自身，所以一个函数调用自身叫作递归。 1234567function power(base, exponent) &#123; if(exponent === 0) &#123; return 1 &#125; else &#123; return base * power(base, exponent - 1) &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门阅读笔记 - Generator 函数 - 又一种异步操作]]></title>
    <url>%2F2018%2F01%2F30%2FES6%20Reading%20Notes%20-%20Generator%2F</url>
    <content type="text"><![CDATA[基本概念Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 1234567function* helloWorldGenerator() &#123; yield &apos;hello&apos; yield &apos;world&apos; return &apos;ending&apos;&#125;var hw = helloWorldGenerator() 上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。 然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 1234567891011hw.next()// &#123; value: &apos;hello&apos;, done: false &#125;hw.next()// &#123; value: &apos;world&apos;, done: false &#125;hw.next()// &#123; value: &apos;ending&apos;, done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。 第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值world，done属性的值false，表示遍历还没有结束。 第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。 第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。 总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。 yield 表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。 需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 1234567891011let num1 = 123let num2 = 456let sum = 0function* gen() &#123; yield sum = num1 + num2&#125;var g = gen()console.log(sum) // 0g.next()console.log(sum) // 678 next 方法的参数yield 表达式本身没有返回值，或者说总是返回 undefined。next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。 123456789101112function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125; 上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。 再看一个例子。 123456789101112131415function* foo(x) &#123; let y = 2 * (yield (x + 1)) let z = yield (y / 3) return (x + y + z)&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;a.next() // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125; 上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。 如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。 注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。 再看一个通过next方法的参数，向 Generator 函数内部输入值的例子。 1234567891011121314function* dataConsumer() &#123; console.log(&apos;Started&apos;); console.log(`1. $&#123;yield&#125;`); console.log(`2. $&#123;yield&#125;`); return &apos;result&apos;;&#125;let genObj = dataConsumer();genObj.next();// StartedgenObj.next(&apos;a&apos;)// 1. agenObj.next(&apos;b&apos;)// 2. b 上面代码是一个很直观的例子，每次通过next方法向 Generator 函数输入值，然后打印出来。 如果想要第一次调用next方法时，就能够输入值，可以在 Generator 函数外面再包一层。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门阅读笔记 - Promise 对象 - 异步操作]]></title>
    <url>%2F2018%2F01%2F29%2FES6%20Reading%20Notes%20-%20Promise%2F</url>
    <content type="text"><![CDATA[1. Promise 的含义所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 2. 基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 下面代码创造了一个Promise实例。1234567const promise = new Promise(function(resolve, reject)&#123; if (true) &#123; /** 异步操作成功 */ resolve(value) &#125; else &#123; /** 异步操作失败 */ reject(error) &#125;&#125;) Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve 函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 12345promise.then(function(value) &#123; console.log(value)&#125;, function(error)&#123; console.log(error)&#125;) 下面是一个Promise对象的简单例子。 12345678910111213141516function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; // setTimeout的第三个参数（可多个），表示延时到了后，作为参数传入给 第一个参数 function setTimeout(resolve, ms, &apos;done&apos;) // 所以上面的代码也等于 setTimeout(resolve(&apos;done&apos;), ms) // 需要注意的是resolve只接受一个参数，如果写成下面这样是只传了第一个值的 setTimeout(resolve, ms, &apos;done1&apos;, &apos;done2&apos;, &apos;done3&apos;) // 上面代码实际只传了&apos;done1&apos; &#125;)&#125;timeout(1000).then((value) =&gt; &#123; console.log(value)&#125;)// delay 100ms show the log &apos;done&apos; Promise 新建后就会立即执行。 1234567891011121314let promise = new Promise((resolve, reject) =&gt; &#123; console.log(&apos;Promise&apos;) resolve()&#125;)promise.then(() =&gt; &#123; console.log(&apos;resolved.&apos;)&#125;)console.log(&apos;Hi!&apos;)// Promise// Hi!// resolved 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 下面是异步加载图片的例子。 123456789101112131415161718192021222324252627const loadImageAsync = (url) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const image = new Image() image.onload = () =&gt; &#123; resolve(image) &#125; image.onerror = () =&gt; &#123; reject(new Error(&apos;Could not load image at &apos; + url)) &#125; image.src = url &#125;)&#125;// HTML 代码&lt;div id=&quot;dd&quot;&gt;&lt;/div&gt;// JS 代码loadImageAsync(&apos;http://p5iwg2uga.bkt.clouddn.com/1.jpg&apos;).then((value) =&gt; &#123; console.log(value) document.getElementById(&apos;dd&apos;).append(value) document.getElementsByTagName(&apos;img&apos;).style.width = &apos;200px&apos; &#125;, (err) =&gt; &#123; console.log(err)&#125;) 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 123456789101112131415161718192021222324252627282930313233const getJSON = (opt) =&gt; &#123; let &#123;url, type = &apos;GET&apos;, responseType = &apos;json&apos;&#125; = opt console.log(url, type, responseType) const promise = new Promise((resolve, reject) =&gt; &#123; const request = new XMLHttpRequest() // 新建XMLHttpRequest对象 request.onreadystatechange = () =&gt; &#123; // readyState发生变化时，函数被回调 if (request.readyState === 4) &#123; // 成功完成 // 判断响应结果： if (request.status === 200) &#123; // 成功，通过 requestText 拿到响应的文本 resolve(request.responseText) &#125; else &#123; reject(new Error(request.status)) &#125; &#125; else &#123; reject(new request.status) &#125; &#125; request.responseType = responseType request.setRequestHeader(&apos;Accept&apos;, &apos;application/json&apos;) request.open(type, url) request.send() &#125;) return promise&#125;// 使用getJSON(&#123;url:&apos;http://www.baidu.com&apos;&#125;).then((data) =&gt; &#123; console.log(&apos;requestText: &apos; + data)&#125;, (err) =&gt; &#123; console.error(&apos;歹势：&apos; + err)&#125;) 上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。 1234567const p1 = new Promise((resolve, reject) =&gt; &#123; // the first todo list&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; // the second todo list resolve(p1)&#125;) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 12345678910111213141516const p1 = new Promise((resolve, reject) =&gt; &#123; console.log(&apos;p1 start&apos;) setTimeout(() =&gt; reject(new Error(&apos;fail&apos;), 3000))&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; // ... console.log(&apos;p2 start&apos;) setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2.then(result =&gt; console.log(result)).catch(error =&gt; console.log(error))// p1 start// p2 start // error fail 上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 12345new Promise((resolve, reject) =&gt; &#123; return resolve(1) // 后面的语句不会再执行 console.log(2)&#125;) 3. Promise.prototype.then()then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345getJSON(&quot;/posts.json&quot;).then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 4. Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 1234567891011121314getJSON(&apos;/posts.json&apos;).then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&apos;发生错误！&apos;, error);&#125;);// 上面的写法等同于getJSON(&apos;/posts.json&apos;).then(function(posts) &#123; // ...&#125;,function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&apos;发生错误！&apos;, error);&#125;); then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。比如下面这样 1234567const promise = new Promise(function(resolve, reject) &#123; throw new Error(&apos;test&apos;);&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// Error: test Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 1234567getJSON(&apos;/post/1.json&apos;).then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function(comments) &#123; // some code&#125;).catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;); 上面代码中，一共有三个 Promise 对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。12345678910111213141516// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 5. Promise.prototype.finally()finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 1234promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); 上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 6. Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.all([p1, p2, p3) 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。） p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 可以理解成后面的参数的返回是 &amp;&amp; 符号，fulfilled 为 true ，rejected 为 false 下面是一个具体的例子。 1234567const promise = [2, 3, 5, 7, 11, 13].map(id =&gt; getJSON(&apos;/post/&apos; + id + &apos;.json&apos;))Promise.all(promise) .then( posts =&gt; &apos;success&apos;, error =&gt; &apos;error&apos;) 上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。 7. 应用加载图片 我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。这个上面已经写过。 1234567891011121314const preloadImage = (path) =&gt; &#123; let promise = new Promise((resolve, reject) =&gt; &#123; const image = new Image() image.onload = reject(image) image.onerror = reject(&apos;load failed&apos;) image.src = path &#125;)&#125;preloadImage(&apos;xxx.jpg&apos;).then((image) =&gt; &#123; // append to the html or another&#125;).catch((err) =&gt; &#123; // show the fail message&#125;) 链式操作减少回调地狱 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const asyncFoo1 = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;异步操作1完成&apos;) resolve(&apos;随便什么数据1&apos;) &#125;,1000) &#125;)&#125;const asyncFoo2 = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;异步操作2完成&apos;) resolve(&apos;随便什么数据2&apos;) &#125;,2000) &#125;)&#125;const asyncFoo3 = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;异步操作3完成&apos;) resolve(&apos;随便什么数据3&apos;) &#125;,3000) &#125;)&#125;asyncFoo1().then((data) =&gt; &#123; console.log(data) return asyncFoo2()&#125;).then((data) =&gt; &#123; console.log(data) return asyncFoo3()&#125;).then((data) =&gt; &#123; console.log(data)&#125;)// 1秒后// 异步操作1完成// 随便什么数据1// 2秒后// 异步操作2完成// 随便什么数据2// 3秒后// 异步操作3完成// 随便什么数据3// 使用Promise.allPromise.all([asyncFoo1(), asyncFoo2(), asyncFoo3()])// 使用Promise.racePromise.race([asyncFoo1(), asyncFoo2(), asyncFoo3()]).then((results) =&gt; &#123; console.log(results)&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门阅读笔记 - Reflect - 操作对象]]></title>
    <url>%2F2018%2F01%2F28%2FES6%20Reading%20Notes%20-%20Reflect%2F</url>
    <content type="text"><![CDATA[1. 概述Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。 Reflect.get(target, name, receiver)Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。 1234567891011let myObject = &#123; foo: 1, bar: 2, get baz() &#123; return this.foo + this.bar &#125;&#125;Reflect.get(myObject, &apos;foo&apos;) //1Reflect.get(myObject, &apos;bar&apos;) //2Reflect.get(myObject, &apos;baz&apos;) //3 Reflect.set(target, name, value, receiver)Reflect.set方法设置target对象的name属性等于value。 1234567891011121314let myObject = &#123; foo: 1, set bar(value) &#123; return this.foo = value &#125;&#125;console.log(myObject.foo) // 1Reflect.set(myObject, &apos;foo&apos;, 2)console.log(myObject.foo) // 2Reflect.set(myObject, &apos;foo&apos;, 3)console.log(myObject.foo) // 3 Reflect.has(obj, name)Reflect.has方法对应name in obj里面的in运算符。 123456789let myObject = &#123; foo: 1&#125;// 旧写法console.log(&apos;foo&apos; in myObject) // true// 新写法console.log(Reflect.has(myObject, &apos;foo&apos;)) // true Reflect.deleteProperty(obj, name)Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。 1234567const myObj = &#123;foo: &apos;bar&apos;&#125;// 旧写法delete myObj.foo// 新写法Reflect.deleteProperty(myObj, &apos;foo&apos;) 该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门阅读笔记 - Set和Map数据结构]]></title>
    <url>%2F2018%2F01%2F27%2FES6%20Reading%20Notes%20-%20SetMap%2F</url>
    <content type="text"><![CDATA[1. Set基本用法 ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set 本身是一个构造函数，用来生成 Set 数据结构。 12345678const s = new Set()[2, 3, 4, 5, 4, 2, 2].forEach(x =&gt; s.add(x))for(const i of s) &#123; console.log(i)&#125;// 2 3 4 5 上面代码通过add方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。 Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。 12345678910111213141516171819// 例一const set = new Set([1,2,3,4,5,5])[...set]// [1,2,3,4,5]// 例二const items = new Set([1,2,3,4,5,6,5,6,6,6])items.size // 5// 例三const set = new Set(document.querySelectorAll(&apos;div&apos;))set.size // 56// 类似于const set = new Set()docuement .querySelectorAll(&apos;div&apos;) .forEach(div =&gt; set.add(div))set.size 结合 Set 成员不会重复的特性，我们可以写出一种去除数组重复的方法。 12// 去除数组的重复成员[...new Set(array)] 向 Set 加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。 12345678910const set = new Set()set.add(+0)// 0set.add(-0)// 0set.add(NaN)// 0, NaNset.add(NaN)// 0, NaN Set 实例的属性和方法Set 结构的实例有以下属性。 Set.prototype.constructor: 构造函数，默认就是Set函数。 Set.prototype.size: 返回 Set 实例的成员总数 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面是四个操作方法： add(value): 添加某个值，返回 Set 结构本身 delete(value): 删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为 Set 的成员 clear()：清除所有成员，没有返回值。 代码如下： 1234567891011s.add(1).add(2).add(2)// 2 虽然被添加了2次，但是实际在 set 只添加了一个，第二次的被覆盖了s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2) // 删除一个成员s.has(2) // false Array.from 方法可以将 Set 结构转为数组。 12const items = new Set([1,2,3,4,5])const array = Array.from(items) 这也是一种数组去重的方法 123const dedupe = arr =&gt; Array.from(new Set(arr)) dedupe([1,2,2,3,4,5,1]) // [1,2,3,4,5] 遍历方法 Set 结构的实例有四个遍历方法，可以用于遍历成员。 keys(): 返回键名的遍历器 values(): 返回键值的遍历器 entries(): 返回键值对的遍历器 forEach(): 使用回调函数遍历每个成员 需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。 keys(),values(),entries() 1234567891011121314151617181920212223242526272829let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;])for(let item of set) &#123; console.log(item)&#125;// red// green// bluefor (let item of set.keys()) &#123; console.log(item)&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item)&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item)&#125;// [&apos;red&apos;, &apos;red&apos;]// [&apos;green&apos;, &apos;green&apos;]// [&apos;blue&apos;, &apos;blue&apos;] 上面代码中，前面3种遍历输出的结果完全一样。entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。 forEach() Set 结构的实例与数组一样，也拥有 forEach 方法，用于遍历每个成员执行某种操作，没有返回值。 1234set.forEach((value, key) =&gt; console.log(`$&#123;key&#125;: $&#123;value&#125;`))// red: red// green: green// blue: blue 遍历的应用扩展运算符 (...) 内部使用 for...of 循环，所以也可以用于 Set 结构。 12let arr = [...set]// [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;] 扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。 1234let arr = [3,4,5,5,6,2]let unique = [...new Set(arr)]//[3,4,5,6,2] 而且，数组的 map 和 filter 方法也可以间接用于 Set 了 123456let set = new Set([1,2,3])set = new Set([...set].map(x =&gt; x * 2))// 返回Set结构 &#123;2,4,6&#125;let set = new Set([1,2,3,4,5])set = new Set([...set].filter(x =&gt; (x % 2 ) === 0))// 返回Set结构 &#123;2,4&#125; 因此使用 Set 可以很容易地实现并集，交集和差集。 1234567891011121314var a = new Set([1,2,3,4])var b = new Set([3,2])// 并集let union = new Set([...a, ...b])// Set &#123;1,2,3,4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)))// Set &#123;2,3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)))// Set &#123;1,4&#125; Map含义和基本用法JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 12345const data = &#123;&#125;const element = document.getElementById(&apos;myDiv&apos;)data[element] = &apos;metadata&apos;data[&apos;[object HTMLDivElement]&apos;] // &apos;metadata&apos; 上面代码原意是将一个 DOM 节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[object HTMLDivElement]。 123456789const m = new Map()cosnt o = &#123;p: &apos;hello World&apos;&#125;m.set(o, &apos;content&apos;)m.get(o)m.has(o)m.delete(o) // truem.has(o) // false Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。 12345678910const map = new Map(&#123; [&apos;name&apos;, &apos;张三&apos;], [&apos;title&apos;, &apos;Author&apos;]&#125;)map.size //3map.has(&apos;name&apos;) // truemap.get(&apos;name&apos;) // &apos;张三&apos;map.has(&apos;title&apos;) // truemap.set(&apos;title&apos;) // &apos;Author&apos; Map构造函数接受数组作为参数，实际上执行的是下面的算法。 12345678cosnt items = [ [&apos;name&apos;, &apos;张山&apos;], [&apos;title&apos;, &apos;Author&apos;]]const map = new Map()items.forEach(([key, value]) =&gt; map.set(key, value)) 如果对同一键多次赋值，后面的值将会覆盖前面的值。 1234567const map = new Map()map .set(1, &apos;aaa&apos;) .set(1, &apos;bbb&apos;) map.get(1) // &apos;bbb&apos; 注意，只有对同一个内存地址的引用，Map 结构才将其视为同一个键。 12345678910111213141516const map = new Map()map.set([&apos;a&apos;], 555)map.get([&apos;a&apos;]) // undefined// 再次set 也不会覆盖map.set([&apos;a&apos;], 6666)map // Set &#123;[&apos;a&apos;]=&gt;555,[&apos;b&apos;]=&gt;6666&#125;map.delete([&apos;a&apos;]) // false 删除失败// 避免这种情况我们可以先将值赋值给一个变量var a = [&apos;a&apos;]map.set(a, 555)map.set(a, 666) map.get(a) // 666map.delete(a) // true// 这样就可以了 还有一种情况，同样的值的两个实例，内存地址不一样的话，也会被视为两个不同的键 123456789const map = new Map()const k1 = [&apos;a&apos;]const k2 = [&apos;a&apos;]map.set(k1, 111).set(k2, 222)map.get(k1) // 111map.get(k2) // 222 总之，Map的键值是一个非简单类型的值时，总是执行的 === 的。如果是简单类型的值，则只要两个值严格相等。 123456789101112131415let map = new Map();map.set(-0, 123);map.get(+0) // 123map.set(true, 1);map.set(&apos;true&apos;, 2);map.get(true) // 1map.set(undefined, 3);map.set(null, 4);map.get(undefined) // 3map.set(NaN, 123);map.get(NaN) // 123 实例的属性和操作方法 size 属性 返回 Map 结构的成员总署 12345const map = new Map()map.set(&apos;foo&apos;, true)map.set(&apos;bar&apos;, false)map.size // 2 set(key, value) set 方法设置键名 key 对应的键值为 value，然后返回整个 Map 结构。如果 key 已经有值，则键值会被更新，否则生成一个新键值。 123m.set(&apos;edition&apos;, 6) // 键是字符串m.set(262, &apos;standard&apos;) // 键是数值m.set(undefined, &apos;nan&apos;) // 键是 undefined get(key) get 方法读取 key 对应的键值，如果找不到 key，返回 undefined has(key) has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。 1234m.has(&apos;edition&apos;) // truem.has(&apos;years&apos;) // falsem.has(262) // truem.has(undefined) // true delete(key) delete 方法删除某个键，返回 true。如果删除失败，返回 false。 12m.delete(undefined)m.has(undefined) // false clear() clear 方法清除所有成员，没有返回值。 123456789101112map.size // 2map.clear()map.size // 0// 大概是等于这样const clear = (m) =&gt; &#123; for(let k of m.keys()) &#123; m.delete(k) &#125;&#125;clear(map) 遍历方法Map 和 Set 一样提供三个遍历器生成函数和一个遍历方法。 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历 Map 的所有成员。 需要特别注意的是，Map 的遍历顺序就是插入顺序。这个和Set是一样的 123456789101112131415161718192021222324252627282930313233343536const map = new Map([ [&apos;F&apos;, &apos;no&apos;], [&apos;T&apos;, &apos;yes&apos;]])for (let key of map.keys()) &#123; console.log(key)&#125;// &apos;F&apos;// &apos;T&apos;for (let value of map.values()) &#123; console.log(value);&#125;// &quot;no&quot;// &quot;yes&quot;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot; Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）。 1234567891011121314151617const map = new Map([ [1, &apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;],]);[...map.keys()]// [1,2,3][...map.values()]// [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;][...map.entries()]// [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]][...map] // [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]] 此外，Map 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。 123map.forEach(function(value, key, map) &#123; console.log(&quot;Key: %s, Value: %s&quot;, key, value);&#125;); Map 和 其他数据类型的相互转换1，Map 转为数组 123const mymap = new Map().set(true,8).set(&#123;foo:3&#125;, &#123;say: &apos;lala&apos;&#125;)[...mymap]// [[&#123;foo:3&#125;],[&#123;say: &apos;lala&apos;&#125;]] 2，数组转为 Map将数组传入Map 构造函数就可以转为Map 1234567891011121314151617181920new Map([ [true, 7], [&#123;foo: 3&#125;, [&apos;abc&apos;]]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]// &#125;// 两个一维数组，分别作为键值传入const setMap = (keyarr, valuearr) =&gt; &#123; let m = new Map() keyarr.forEach((ele,index) =&gt; &#123; m.set(ele, valuearr[index]) &#125;) return m&#125;setMap([1,2,3],[&apos;one&apos;,&apos;two&apos;,&apos;three&apos;])// Map(3) &#123;1 =&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;, 3 =&gt; &quot;three&quot;&#125; Map 转为对象 如果所有Map 的键都是字符串，它可以无损的转为对象 12345678910const strMapToObj = (strMap) =&gt; &#123; let obj = Object.create(null,&#123;&#125;) for (let [k,v] of strMap) &#123; obj[k] = v &#125; return obj&#125;strMapToObj(new Map([[&apos;yes&apos;, true],[&apos;no&apos;, false]]))// &#123;yes: true, no: false&#125; 对象转为 Map 12345678910const ObjToMap = (obj) =&gt; &#123; let map = new Map() for (let k in obj) &#123; map.set(k, obj[k]) &#125; return map&#125;ObjToMap(&#123;yes: true, no: false&#125;)// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125; Map 转为 JSON Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。 12345const strMapToJson = strMap =&gt; JSON.stringify(strMapToObj(strMap))let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);strMapToJson(myMap)// &apos;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&apos; 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。 1234567function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);mapToArrayJson(myMap)// &apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos; JSON 转为 Map JSON 转为 Map，正常情况下，所有键名都是字符串。 123456function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap(&apos;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&apos;)// Map &#123;&apos;yes&apos; =&gt; true, &apos;no&apos; =&gt; false&#125; 但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。 123456function jsonToMap(jsonStr) &#123; return new Map(JSON.parse(jsonStr));&#125;jsonToMap(&apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;)// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门阅读笔记 - 对象的扩展]]></title>
    <url>%2F2018%2F01%2F26%2FES6%20Reading%20Notes%20-%20Object%2F</url>
    <content type="text"><![CDATA[1. 属性的简洁表示法ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 123456const foo = &apos;bar&apos;;const baz = &#123;foo&#125;;baz // &#123;foo: &quot;bar&quot;&#125;// 等同于const baz = &#123;foo: foo&#125;; 上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。123456const f = (name, age) =&gt; &#123;return &#123;name, age&#125;&#125;//等同于const f = (name, age) =&gt; &#123;return &#123;name: name, age: age&#125;&#125;f(&apos;slash&apos;, 28) // Object &#123;name: &apos;slash&apos;, age: 28&#125; 除了属性简写，方法也可以简写 12345678910111213const o = &#123; method() &#123; return &apos;Hello!&apos; &#125;&#125;//等同于const o = &#123; method: function ()&#123; return &apos;Hello!&apos; &#125;&#125; 我的理解后面是一个匿名函数 等同于 value 值是 ()一个实际栗子：1234567891011let birth = &apos;1989/04/27&apos;const person = &#123; name: &apos;slash&apos;, birth, // 等于 birth: birth //等同于 hello: function()&#123;...&#125; hello() &#123; console.log(`我的名字是$&#123;this.name&#125;`) &#125;&#125; 这种写法用于函数的返回值，将会非常方便。 12345678const getPoint = () =&gt; &#123; const x = 1 const y = 10 return &#123;x, y&#125;&#125;getPoint() // &#123;x: 1, y: 10&#125; 属性的赋值器(setter)和取值器(getter)123456789101112131415161718var cart = &#123; _var1: 1, _var2: 2, get var1 () &#123; return this._var1 &#125;, set var1 (value) &#123; if(value &lt; this._var1) throw new Error(&apos;var1数值太小了&apos;) this._var1 = value &#125;, get var2 () &#123; return this._var2 &#125;, set var2 (value) &#123; if(value &lt; this._var2) throw new Error(&apos;var2数值太小了&apos;) this._var2 = value &#125;&#125; 2. 属性名表达式JavaScript 定义对象的属性，有两种方法。 12345// 方法一obj.foo = true;// 方法二obj[&apos;a&apos; + &apos;bc&apos;] = 123; 正常的属性名一般采用 . 方式访问和设置属性值，一些特殊符号可以使用[‘name’]的方式。 但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。 1234var obj = &#123; foo: true, abc: 123&#125; ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。123456let propKey = &apos;foo&apos;;let obj = &#123; [propKey]: true, [&apos;a&apos; + &apos;bc&apos;]: 123&#125;; 3. 方法的函数名函数的 name 属性，返回函数名。对象方法也是函数，因此也有 name 属性。 1234567const person = &#123; sayName() &#123; console.log(&apos;hello!&apos;) &#125;&#125;person.sayName.name // &apos;sayname&apos; 4. Object.is()ES5 比较两个值是否相等，只有两个运算符：相等运算符（ == ）和严格相等运算符（ === ）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。 ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。 123Object.is(&apos;foo&apos;, &apos;foo&apos;) //trueObject.is(&#123;&#125;,&#123;&#125;) //false 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true 5. Object.assign()Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 12345678const target = &#123; a: 1 &#125;cosnt source1 = &#123; b: 2 &#125;const source2 = &#123; c: 3 &#125;Object.assign(target, source1, sourece2)traget // &#123;a: 1, b: 2, c: 3&#125; Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 1234567const target = &#123; a: 1, b: 1&#125;const source1 = &#123; b: 2, c: 2&#125;const source2 = &#123; c: 3&#125;Object.assign(target, source1, source2)target // &#123;a: 1, b: 2, c: 3&#125; 建议只传入对象，传入单独数字或者字符串时处理结果不一。 注意点 浅拷贝 Object.assign() 方法实行的是浅拷贝，而不是深拷贝。也就是说，改变源对象某个属性，拷贝后得到的对象是这个源对象的引用 12345const obj1 = &#123;a: &#123;b: 1&#125;&#125;const obj2 = Object.assign(&#123;&#125;, obj1)obj1.a.b = 2obj2.a.b // 2 常见用途1. 为对象添加属性12345class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;) &#125;&#125; 上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。 2.为对象添加方法12345678910111213141516Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; // do somethings ... &#125;, anotherMethod()&#123; // do somethings .. &#125;&#125;)// 等同于下面的方法SomeClass.prototype.someMethod = function (arg1, arg2) &#123; // do somethings ...&#125;SomeClass.prototype.anotherMethod = function () &#123; // do somethings ...&#125; 上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。 3.合并多个对象将多个对象合并到某个对象 1const merge = (target, ...sources) =&gt; Object.assign(target, ...sources) 如果希望合并后返回一个新的对象，可以改下上面的函数，对一个空对象合并1const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources) 4. 为属性指定默认值12345678910111213141516171819202122232425262728293031323334353637383940const DEFAULTS = &#123; logLevel: 0, outputFormat: &apos;html&apos;&#125;const processContent = (options) =&gt; &#123; options = Object.assign(&#123;&#125;, DEFAULTS, options) console.log(options) // 其实就是合并了默认的对象和新的对象，并对一个空对象合并&#125;// 例如我们要封装一个 小程序的 request 请求，先设置一些通用的属性const DEFAULT_REQUEST_OPTIONS = &#123; url:&apos;&apos;, data:&#123;&#125;, header: &#123; &apos;Content-Type&apos;: &apos;application/json&apos; &#125;, method: &apos;POST&apos;, dataType: &apos;json&apos;&#125;function request (opt) &#123; // 合并新旧对象，如果opt有重复的属性则会覆盖默认的设置 let options = Object.assign(&#123;&#125;, DEFAULT_REQUEST_OPTIONS, opt) // 然后进行解构 let &#123;url, data, header, method, dataType&#125; = options // 最后进行实际的插值请求 wx.request(&#123; url: url, data: data, header: header, method: method, dataType: dataType, success(res) &#123; // get the res &#125; &#125;)&#125; 6. 属性的可枚举性和遍历ES6 一共有 5 种方法可以遍历对象的属性。a. for…infor…in 循环遍历对象自身的和继承的可枚举属性。 b. Object.keys(obj)Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）的键名。 c. Object.getOwnPropertyNames(obj)Object.getOwnPropertyNames 返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包含不可枚举属性）的键名。 e. Object.getOwnPropertySymbols(obj)Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 d. Reflect.ownKeys(obj)Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。 7. 对象的扩展运算符解构赋值对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。 1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门阅读笔记 - Proxy 代理器]]></title>
    <url>%2F2018%2F01%2F26%2FES6%20Reading%20Note%20-%20Proxy%2F</url>
    <content type="text"><![CDATA[1. 概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 123456789101112131415161718var obj = new Proxy( &#123;&#125;, &#123; get: function(target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`) return Reflect.get(target, key, receiver) &#125;, set: function(target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;!`) return Reflect.set(target, key, value, receiver) &#125; &#125;)obj.count = 1// setting count!obj.count++// getting count!// setting count! 上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 1var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。 123456789var proxy = new Proxy(&#123;&#125;,&#123; get: function(target, property) &#123; return 35 &#125;&#125;)proxy.time // 35proxy.name // 35proxy.title // 35 上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。 注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。 如果handler没有设置任何拦截，那就等同于直接通向原对象。 123456var target = &#123;&#125;var handler = &#123;&#125;var proxy = new Proxy(target, handler)proxy.a = &apos;b&apos;traget.a // &apos;b&apos; Proxy 实例也可以作为其他对象的原型对象。 2. Proxy 实例的方法get()get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。 get方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。 12345678910111213141516var person = &#123; name: &quot;张三&quot;&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError(&quot;Property \&quot;&quot; + property + &quot;\&quot; does not exist.&quot;); &#125; &#125;&#125;);proxy.name // &quot;张三&quot;proxy.age // 抛出一个错误 上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。 traget 指向引入的对象 person ，property 值得 get 的属性名， 1234567891011let person = &#123; name: &apos;张三&apos;, age: 58&#125;let proxy = new Proxy(person, &#123; get: function(target, property) &#123; return `target, $&#123;target[property]&#125;` &#125;&#125;)console.log(proxy.name) //target, 张三 get 方法可以继承 12345678910let proto = new Proxy(&#123;&#125;, &#123; get(target, propertyKey, receiver) &#123; console.log(&apos;GET &apos; + propertyKey) return target[propertyKey] &#125;&#125;)let obj = Object.create(proto)console.log(obj.foo) // &apos;GET foo&apos; 上面代码中，拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。 下面的例子使用get拦截，实现数组读取负数的索引。 12345678910111213141516171819function createArray(...elements) &#123; let handler = &#123; get(target, propKey, receiver) &#123; let index = Number(propKey) if (index &lt; 0) &#123; propKey = String(target.length + index) &#125; return Reflect.get(target, propKey, receiver) &#125; &#125; let target = [] target.push(...elements) return new Proxy(target, handler)&#125;let arr = createArray(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)console.log(arr[-1]) 上面代码中，数组的位置参数是-1，就会输出数组的倒数第一个成员。 下面的例子则是利用get拦截，实现一个生成各种 DOM 节点的通用函数dom。 1234567891011121314151617181920212223242526const dom = new Proxy(&#123;&#125;, &#123; get(target, property) &#123; return function (attrs = &#123;&#125;, ...children) &#123; const el = document.createElement(property) for (const prop of Object.keys(attrs)) &#123; &#125; &#125; &#125;&#125;)const el = dom.div(&#123;&#125;, &apos;Hello, my name is &apos;, dom.a(&#123; href: &apos;https://www.baidu.com&apos;, style: &apos;color: red&apos; &#125;, &apos;Mark&apos;), &apos;. I like&apos;, dom.ul(&#123;&#125;, dom.li(&#123;&#125;, &apos;The web&apos;), dom.li(&#123;&#125;, &apos;Food&apos;), dom.li(&#123;&#125;, &apos;...actually that\&apos;s it&apos;) ) )document.body.appendChild(el); 如果一个属性不可配置（configurable）和不可写（writable），则该属性不能被代理，通过 Proxy 对象访问该属性会报错。 set()set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。 假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求。 1234567891011121314151617181920212223let validator = &#123; set: function (obj, prop, value) &#123; if (prop === &apos;age&apos;) &#123; if (!Number.isInteger(value)) &#123; throw new TypeError(&apos;The age is not an integer&apos;) &#125; if (value &gt; 200) &#123; throw new RangeError(&apos;The age seems invalid&apos;) &#125; &#125; obj[prop] = value &#125;&#125;let person = new Proxy(&#123;&#125;, validator)person.age = 100person.age // 100person.age = &apos;young&apos; // 报错person.age = 300 // 报错 上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。 有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。 123456789101112131415161718192021222324const handler = &#123; get (target, key) &#123; invariant(key, &apos;get&apos;) return target[key] &#125;, set (target, key, value) &#123; invariant(key, &apos;set&apos;) target[key] = value return true &#125;&#125;function invariant(key, action) &#123; if (key[0] === &apos;_&apos;) &#123; throw new Error(`invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`) &#125;&#125;const target = &#123;&#125;const proxy = new Proxy(target, handler)proxy._prop // throw errorproxy._prop = &apos;c&apos; // throw error 上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门阅读笔记 - 字符串的扩展]]></title>
    <url>%2F2018%2F01%2F24%2FES6%20Reading%20Notes%20-%20String%2F</url>
    <content type="text"><![CDATA[增加的内容1. 字符串的遍历器接口123456for (const char of &apos;foo&apos;) &#123; console.log(char)&#125;// &apos;f&apos;// &apos;o&apos;// &apos;o&apos; 增加了 for...of 循环遍历 2. at(index)返回字符串给定位置的字符。和 charAt 方法一样，但 charAt 不能识别码点大于 0xFFFF 的字符，目前支持度很低，不推荐使用1234567&apos;hello&apos;.at(0) // &apos;h&apos;&apos;hello&apos;.charAt(0) // &apos;h&apos;&apos;hello&apos;[0] // &apos;h&apos;&apos;𠮷&apos;.at(0) // &apos;𠮷&apos;&apos;𠮷&apos;.charAt(0) // &apos;\uD842&apos;&apos;𠮷&apos;[0] // &apos;\uD842&apos; 3. includes(),startsWith(),endsWith() includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 12345let s = &apos;Hello world!&apos;s.startsWith(&apos;Hello&apos;) // trues.endsWith(&apos;!&apos;) // trues.includes(&apos;o&apos;) // true 这三个参数都支持第二个参数，表示开始搜索的位置 123s.startsWith(&apos;world&apos;, 6) // trues.endsWith(&apos;Hello&apos;, 6) // trues.includes(&apos;Hello&apos;, 6) // false 4. repeat()repeat 方法返回一个字符串，表示将原字符串重复 n 次 12345&apos;帅&apos;.repeat(3) // &apos;帅帅帅&apos;&apos;hi&apos;.repeat(2) // &apos;hihi&apos;&apos;na&apos;.repeat(0) // &apos;&apos;&apos;na&apos;.repeat(2.9) // &apos;nana&apos;&apos;na&apos;.repeat(-1) // RangeError 5. padStart(), padEnd()字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。 padStart()用于头部补全，padEnd()用于尾部补全。 12&apos;a&apos;.padStart(5, &apos;ab&apos;) // ababa&apos;a&apos;.padEnd(5, &apos;ab&apos;) // aabab 一个栗子: 时分秒小于10的补全1234const formatTime = (time) =&gt; time.toString().padStart(2, &apos;0&apos;)formatTime(8) // &apos;08&apos;formatTime(30) // &apos;30&apos; 6. 模版字符串这个应该都经常在用了 123456789let content = &apos;I&apos;m the content!&apos;/* the old methods */let div = &apos;&lt;div&gt;&apos; + content + &apos;&lt;/div&gt;&apos;/* the new methods */let content = `&lt;div&gt;$&#123;content&#125;&lt;/div&gt;` 字符串用 ` 包起来，变量则用${}括起来，在${}` 中还支持 运算 1let data = `$&#123;1 + 2&#125;` // &apos;3&apos; 注意最终得到的都是一个字符串]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门阅读笔记 - 数组的扩展]]></title>
    <url>%2F2018%2F01%2F23%2FES6%20Reading%20Notes%20-%20Array%2F</url>
    <content type="text"><![CDATA[1. 扩展运算符扩展运算符(spread)是三个点(…)。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12345678console.log(...[1,2,3])// 1 2 3console.log(1, ...[1,2,3], 5)// 1 2 3 4 5[...document.querySelectorAll(&apos;div&apos;)]// [&lt;div&gt;,&lt;div&gt;,&lt;div&gt;] 改运算符主要用于函数调用 123456const push = (array, ...items) =&gt; &#123;array.push(...items)&#125;const add = (x, y) =&gt; return x + yconst numbers = [4, 38]add(...numbers) // 42 扩展运算符与正常的函数参数可以结合使用，非常灵活 123const f = (v, w, x, y, z) =&gt; &#123;&#125;const args = [0, 1]f(-1, ...args, 2, ...[3]) 2. 扩展运算符的应用2.1 复制数组数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。 123456789101112131415161718192021const a1 = [1,2]const a2 = a1a2[0] = 2a1 // [2, 2]/* the old methods */const a1 = [1,2]const a2 = a1.concat()a2[0] = 2a1 // [1, 2]/* the new methods */const a1 = [1, 2]// the new one const a2 = [...a1]// the new twoconst [...a2] = a1 2.2 合并数组扩展运算符提供了数组合并的新写法。 123456// ES5 [1, 2].concat([3,4])[&apos;a&apos;,&apos;b&apos;].concat([&apos;c&apos;,&apos;d&apos;],[&apos;e&apos;,&apos;f&apos;])// ES6[1, 2, ...[3, 4]][...[&apos;a&apos;,&apos;b&apos;], ...[&apos;c&apos;,&apos;d&apos;], ...[&apos;e&apos;,&apos;f&apos;]] 2.3 与解构赋值结合扩展运算符可以与解构赋值结合起来，用于生成数组 123const [first, ...rest] = [1,2,3,4,5]fisrt // 1rest // [2,3,4,5] 2.4 字符串扩展运算符可以将字符串变成数组 12[...&apos;hello&apos;]// [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;] 2.5 实现了 Iterator 接口的对象任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。 12let nodeList = document.querySelectorAll(&apos;div&apos;)let array = [...nodelist] 3. Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 下面是一个类似数组的对象，Array.from将它转为真正的数组。 1234567891011let arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3&#125;// ES5var arr1 = [].silce.call(arrayLike) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]// ES6var arr2 = Array.from(arrayLike) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。常见的如DOM操作返回的 NodeList 集合 或者 arguments 123456789// NodeList 对象let ps = document.querySelectorAll(&apos;p&apos;)Array.from(ps).filter(p =&gt; p.textContent.length &gt; 100)// arguments 对象const foo () &#123; let args = Array.from(arguments) // ...&#125; Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] Array.from()可以将各种值转为真正的数组，并且还提供map功能。 12Array.from(&#123; length: 2 &#125;, () =&gt; &apos;jack&apos;)// [&apos;jack&apos;, &apos;jack&apos;] 下面一个例子演示如何将一个数组切割成指定大小的若干个小数组 123456const chunk = (arr, size) =&gt; Array.from(&#123;length: Match.ceil(arr.length / size)&#125;, (v, i) =&gt; arr.slice(i * size, i * size + size) )chunk([1, 2, 3, 4, 5], 2) // [[1, 2], [3, 4], 5] 4. Array.of()Array.of方法用于将一组值，转换为数组。 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] 5. Array.copyWithin()1Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 6. Array.find() 和 Array.findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 1[1, 4, -5, 10].find((n) =&gt; n &lt; 0) 早到第一个值后就会返回，如果需要找到全部的值，可以用 Array.filter() 7. 数组实例的 fill()fill 方法使用给定值，填充一个数组。 12[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)// [7,7,7] 上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。 fill 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 12[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)// [&apos;a&apos;, 7, &apos;c&apos;] 上面代码表示，fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。 123456789let arr = new Array(3).fill(&#123;name: &quot;Mike&quot;&#125;);arr[0].name = &quot;Ben&quot;;arr// [&#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;]let arr = new Array(3).fill([]);arr[0].push(5);arr// [[5], [5], [5]] 总结就是，要变大家一起变~~ 8. 数组实例的 entries(), keys(), values()ES6 提供三个新的方法——entries()，()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 1234567891011121314151617for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index)&#125;// 0// 1for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123; console.log(elem)&#125;// &apos;a&apos;// &apos;b&apos;for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(index, elem)&#125;// 0 &apos;a&apos;// 1 &apos;b&apos; 如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历。 123456let letter = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]let entries = letter.entries()console.log(entries.next().value) // [0, &apos;a&apos;]console.log(entries.next().value) // [1, &apos;b&apos;]console.log(entries.next().value) // [2, &apos;c&apos;] 记得一定要加 .value, 遍历器对象返回的是 一个含有 ‘done’ 和 ‘value’ 的对象 9. 数组实例的 includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 他可以包含第二个参数，表示搜索的起始位置，默认为0。如果是负数，则表示倒数的位置，如果这时它大于数组的长度，则会重置为0开始。 12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 10. 数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 1Array(3) // [,,,] chrome浏览器的console中显示得更直接 [empty x 3] 但是 空值并不是这个位置的值等于 undefined forEach(), filter(), reduce(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 1234567891011121314151617181920212223// forEach方法[,&apos;a&apos;].forEach((x,i) =&gt; console.log(i));// filter方法[&apos;a&apos;,,&apos;b&apos;].filter(x =&gt; true) // [&apos;a&apos;,&apos;b&apos;]// every方法[,&apos;a&apos;].every(x =&gt; x===&apos;a&apos;) // true// reduce方法[1,,2].reduce((x,y) =&gt; return x+y) // 3// some方法[,&apos;a&apos;].some(x =&gt; x !== &apos;a&apos;) // false// map方法[,&apos;a&apos;].map(x =&gt; 1) // [,1]// join方法[,&apos;a&apos;,undefined,null].join(&apos;#&apos;) // &quot;#a##&quot;// toString方法[,&apos;a&apos;,undefined,null].toString() // &quot;,a,,&quot; ES6 则是明确将空位转为undefined。 12Array.from([&apos;a&apos;,,&apos;b&apos;])// [ &quot;a&quot;, undefined, &quot;b&quot; ] 扩展运算符 (…) 也会将空位转为 undefined 12[...[&apos;a&apos;,,&apos;b&apos;]]// [&apos;a&apos;, undefined, &apos;b&apos;] PS:由于空位的处理规则非常不统一，所以建议避免出现空位。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门阅读笔记 - 函数的扩展]]></title>
    <url>%2F2018%2F01%2F20%2FES6%20Reading%20Notes%20-%20Function%2F</url>
    <content type="text"><![CDATA[函数的默认值ES5默认值的写法 12345678function log(x, y) &#123; y = y || &apos;World&apos;; console.log(x, y);&#125;log(&apos;Hello&apos;) // Hello Worldlog(&apos;Hello&apos;, &apos;China&apos;) // Hello Chinalog(&apos;Hello&apos;, &apos;&apos;) // Hello World 上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。 ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 1234567function log(x, y = &apos;World&apos;) &#123; console.log(x, y);&#125;log(&apos;Hello&apos;) // Hello Worldlog(&apos;Hello&apos;, &apos;China&apos;) // Hello Chinalog(&apos;Hello&apos;, &apos;&apos;) // Hello 可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。 1234567function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125;const p = new Point();p // &#123; x: 0, y: 0 &#125; 函数的length指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。 123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 rest 参数ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。 123456789function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a = [];push(a, 1, 2, 3) 箭头函数1var f = v =&gt; v; 上面的箭头函数等于123var f = function(v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 也可以作为回调函数使用 12345678910111213[1,2,3].map(x =&gt; x + 1)// 等同于[1,2,3].map(function(x)&#123; return x + 1&#125;)[1,2,3].forEach((x,index,array) =&gt; &#123; array[index] = x + 1&#125;)// 等同于[1,2,3].forEach(function (x,index,array) &#123; array[index] = x + 1&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门阅读笔记 - 函数的扩展]]></title>
    <url>%2F2018%2F01%2F20%2FES6%20Reading%20Notes%20-%20Deconstruction%2F</url>
    <content type="text"><![CDATA[按照一定的规律，从数组和对象中提值。 从数组中提值1234let [a, b, c] = [1, 2, 3]a //1b //2b //3 按数组的顺序进行赋值 123let [a,b] = [1]a //1b //undefined 如果赋值不成功则为undefined 123456let [a, [b, c], d] = [1, [2, 3], 4]a //1b //2c //3d //4 前后的结构要一致 123let [a = 1, b] = [undefined, 3]a //1b //3 支持设置默认值 从对象中提值在对象中使用和数组基本一致，但是由于对象是无序的集合，所以解构时并不按顺序来，而是按照对象的 key 值去赋值 123let &#123;foo, bar&#125; = &#123;bar: &apos;bbb&apos;, foo: &apos;aaa&apos;&#125;foo //&apos;aaa&apos;bar //&apos;bbb&apos; 可见对象的解构并不按顺序，而是按 key 去解构。另外需要注意的是解构的时候变量的结构省略了 value 。实际完整的结构是 1let &#123;foo: foo, bar: bar&#125; = &#123;bar: &apos;bbb&apos;, foo: &apos;aaa&apos;&#125; 所以我们要把对象的某个 key 赋值给其他变量也可以这样 123let &#123;foo: otherVariable&#125; = &#123;foo: &apos;aaa&apos;&#125;foo // foo is not definedotherVariable // &apos;aaa&apos; 可见赋值的变量并不是 左侧的 key 而是 value 位置的变量 1234567891011let obj = &#123; foo: &#123; arr: [1, &#123;isCooool: true&#125;], name: &apos;slash&apos; &#125;&#125;let &#123;foo: &#123; arr: [x, &#123;isCooool: me&#125;], name&#125;&#125; = objx // 1me: // truename: // &apos;slash&apos; 上面是一个对象和数组相互嵌套的例子 1234let &#123;foo = &apos;defaultData&apos;&#125; = &#123;&#125;foo // &apos;defaultData&apos;let &#123;foo = &apos;defaultData&apos;&#125; = &#123;foo: &apos;newData&apos;&#125;foo // &apos;newData&apos; 对象也可以设置默认值 1234567let [a,b,c,d,e,f] = &apos;hello&apos;a //&apos;h&apos;b //&apos;e&apos;c //&apos;l&apos;d //&apos;l&apos;e //&apos;o&apos;f //undefined 字符串在解构时会被当作数组处理 12345678const f = ([x, y]) =&gt; x + yf([1,2]) //3const f = (&#123;firstname, lastname&#125;) =&gt; `My name is $&#123;firstname&#125; $&#123;lastname&#125;`f(&#123;firstname: &apos;slash&apos;, lastname: &apos;chu&apos;&#125;) //&apos;My name is slash chu&apos;[[2,3],[5,8]].map(([a, b]) =&gt; a + b)// [5, 13] 函数的参数也可以使用解构赋值，包括数组或者对象,第三个例子也是数组解构在参数中的一个应用 应用1. 交换值12345678910111213141516let x = 1let y = 2/* the old methods */let z = nullz = xx = yy = zx //2y //1/* the new methods */[x, y] = [y, x]x //2y //1 清爽很多，也不需要另外去申明一个变量 2. 函数多个值123456789101112// return Arrayconst example = () =&gt; [1,2,3]let [a, b, c] = example()a //1b //2c //3// return Objectconst example = () =&gt; &#123;name:&apos;slash&apos;,sexy:&apos;male&apos;&#125;let &#123;name, sexy&#125; = example()name //&apos;slash&apos;sexy //&apos;male&apos; 3. 函数参数的定义123const f = ([x,y,z]) =&gt; x + y + zf([1,2,3]) //6 4. 解析 JSON 数据12345678910111213var jsonData = &#123; name: &apos;monkey.d&apos;, job: &apos;sea poacher&apos;, age: 18, teammates: [&apos;solon&apos;,&apos;namei&apos;]&#125;let &#123;name, job, age, teamates&#125; = jsonDataname //&apos;monkey.d&apos;job //&apos;sea poacher&apos;age //18teammates // [&apos;solon&apos;,&apos;namei&apos;] 可以快速获取JSON中的值 5. 函数的默认值12345678910alert(title = &apos;提示&apos;, content = config.defaultAlterMessage)&#123; if(&apos;object&apos; === typeof content) &#123; content = JSON.stringify(content) || config.defaultAlterMessage &#125; // 最后将得到值传入小程序自带的showModal中 wx.showModal(&#123; title: title, content: content, &#125;) &#125; 上面是封装的一个微信小程序alert组件，默认设置了title以及content 6. 遍历 Map1234567891011const map = new Map([[&apos;fisrt&apos;,&apos;hello&apos;],[&apos;second&apos;,&apos;world&apos;]])/* the old methods*/for(const k of map)&#123; console.log(&apos;k:&apos;, k[0],&apos;value:&apos;, map.get(k[0]))&#125;/* the new methods*/for(const [k,value] of map) &#123; console.log(&apos;k:&apos;, k, &apos;value:&apos;, value)&#125; 看上去简单明了很多123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 如果只想获取 键名 或者 键值 可以向上面一样 7. 输入模块的方法1import &#123; IndexList, IndexSection &#125; from &apos;mint-ui&apos;; 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
